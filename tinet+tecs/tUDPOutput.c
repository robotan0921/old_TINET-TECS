/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tUDPOutput_template.c => src/tUDPOutput.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * require port : signature: sKernel context: task
 *   ER             sleep( );
 *   ER             sleepTimeout( TMO timeout );
 *   ER             delay( RELTIM delayTime );
 *   ER             exitTask( );
 *   ER             getTaskId( ID* p_taskId );
 *   ER             rotateReadyQueue( PRI taskPriority );
 *   ER             getTime( SYSTIM* p_systemTime );
 *   ER             getMicroTime( SYSUTM* p_systemMicroTime );
 *   ER             lockCpu( );
 *   ER             unlockCpu( );
 *   ER             disableDispatch( );
 *   ER             enableDispatch( );
 *   ER             disableTaskException( );
 *   ER             enableTaskException( );
 *   ER             changeInterruptPriorityMask( PRI interruptPriority );
 *   ER             getInterruptPriorityMask( PRI* p_interruptPriority );
 *   ER             exitKernel( );
 *   bool_t         senseContext( );
 *   bool_t         senseLock( );
 *   bool_t         senseDispatch( );
 *   bool_t         senseDispatchPendingState( );
 *   bool_t         senseKernel( );
 * call port : cIPv4CheckSum  signature: sIPv4CheckSum context: task
 *   uint16_t       cIPv4CheckSum_ipv4CheckSum( int8_t* data, int32_t size, uint32_t offset, uint8_t proto );
 * call port : cIPv4Output  signature: sIPv4Output context: task
 *   ER             cIPv4Output_IPv4Output( int8_t* outputp, int32_t size, TMO tmout );
 *   ER             cIPv4Output_getOffset( T_OFF_BUF* offset );
 *   T_IN4_ADDR     cIPv4Output_getIPv4Address( );
 *   void           cIPv4Output_setHeader( int8_t* outputp, int32_t size, T_IN4_ADDR dstaddr, T_IN4_ADDR srcaddr );
 *   ER             cIPv4Output_IPv4Reply( int8_t* outputp, int32_t size, TMO tmout );
 * allocator port for call port: cIPv4Output func: IPv4Output param: outputp
 *   ER             cIPv4Output_IPv4Output_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cIPv4Output_IPv4Output_outputp_dealloc( const void* buf );
 *   ER             cIPv4Output_IPv4Output_outputp_reuse( void* buf );
 *   ER_UINT        cIPv4Output_IPv4Output_outputp_bufferSize( const void* buf );
 *   uint32_t       cIPv4Output_IPv4Output_outputp_bufferMaxSize( );
 * allocator port for call port: cIPv4Output func: IPv4Reply param: outputp
 *   ER             cIPv4Output_IPv4Reply_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cIPv4Output_IPv4Reply_outputp_dealloc( const void* buf );
 *   ER             cIPv4Output_IPv4Reply_outputp_reuse( void* buf );
 *   ER_UINT        cIPv4Output_IPv4Reply_outputp_bufferSize( const void* buf );
 *   uint32_t       cIPv4Output_IPv4Reply_outputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tUDPOutput_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eOutput
 * entry port: eOutput
 * signature:  sUDPOutput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eOutput_UDPOutput
 * name:         eOutput_UDPOutput
 * global_name:  tUDPOutput_eOutput_UDPOutput
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eOutput_UDPOutput(const int8_t* outputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr,int32_t addrlen,uint16_t dstport,uint16_t myport, T_OFF_BUF offset,TMO tmout)
{
	T_NET_BUF	*output;
	T_UDP_HDR	*udph;
	SYSTIM		before, after;
	ER		ercd = E_OK;
	int32_t len;


	int32_t off = offset.ifhdrlen + offset.iphdrlen;
	/* データ長を 4 オクテット境界に調整する。*/
	int32_t align;
	align = (size + 3) >> 2 << 2;

	/* IP データグラム割り当ての時間を tmout から減ずる。*/
	if (!(tmout == TMO_POL || tmout == TMO_FEVR))
	  getTime(&before);

	if((ercd = cIPv4Output_IPv4Output_outputp_alloc( (void**)&output, align+off+UDP_HDR_SIZE-offset.ifalign, tmout )) != E_OK)
		return ercd;

	/* IP データグラム割り当ての時間を tmout から減ずる。*/
	if (!(tmout == TMO_POL || tmout == TMO_FEVR)) {
		getTime(&after);
		if (after - before > tmout) {
			cIPv4Output_IPv4Output_outputp_dealloc((void *)output);
			ercd = E_TMOUT;
			goto err_ret;
		}
		tmout -= (TMO)(after - before);
	}
	
	/* UDP ヘッダに情報を設定する。*/
	udph		= GET_UDP_HDR(output, off);
	udph->sport	= htons(myport);
	udph->dport	= htons(dstport);
	udph->ulen	= htons(UDP_HDR_SIZE + size);
	udph->sum	= 0;

	/* データをコピーする。*/
	memcpy((void*)GET_UDP_SDU(output, off), outputp, (size_t)size);

	//パディングで埋める
	align = (size + 3) >> 2 << 2;
	if (align > size)
		memset((GET_UDP_SDU(output,off) + size), 0, (size_t)(align - size));

	output->off = offset;
	/* ネットワークバッファ長を調整する。*/
	output->len = (uint16_t)(off + UDP_HDR_SIZE + size - offset.ifalign);
	len = output->len + sizeof(T_NET_BUF) - 4 + offset.ifalign;
	
	if((is_cIPv4Output_joined()) && (output->off.protocolflag & FLAG_USE_IPV4)){
		T_IN4_ADDR dst = *((T_IN4_ADDR *)dstaddr);
		T_IN4_ADDR src = *((T_IN4_ADDR *)srcaddr);
		cIPv4Output_setHeader(output, len, dst, src );
		if(is_cIPv4CheckSum_joined()){
			uint16_t	sum;
			sum = cIPv4CheckSum_ipv4CheckSum(output,len,off,IPPROTO_UDP );

			/* 計算したチェックサムの値が 0 なら 0xffff を入れる。*/
			if (sum == 0)
			  sum = 0xffff;
			udph->sum = sum;
		}
		
		/* ネットワーク層 (IP) の出力関数を呼び出す。*/		
		if ((ercd = cIPv4Output_IPv4Output((int8_t*)output,len,tmout )) == E_OK) {
			return size;
		}
		return ercd;
	}
	



	cIPv4Output_IPv4Output_outputp_dealloc((void*)output);
	
err_ret:
	return ercd;
}

/* #[<ENTRY_FUNC>]# eOutput_getOffset
 * name:         eOutput_getOffset
 * global_name:  tUDPOutput_eOutput_getOffset
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eOutput_getOffset(T_OFF_BUF* offset)
{
	offset->tphdrlen = UDP_HDR_SIZE;

	if((is_cIPv4Output_joined()) && (offset->protocolflag & FLAG_USE_IPV4))
	  return cIPv4Output_getOffset(offset);
	
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
