/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tUDPCEP_template.c => src/tUDPCEP.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * attr access macro #_CAAM_#
 * port             uint16_t         ATTR_port       
 * ipLength         int8_t           ATTR_ipLength   
 * myport           uint16_t         VAR_myport      
 * offset           T_OFF_BUF        VAR_offset      
 * flags            uint16_t         VAR_flags       
 * sendTaskID       ID               VAR_sendTaskID  
 * receiveTaskID    ID               VAR_receiveTaskID
 * cb_netbuf        T_NET_BUF*       VAR_cb_netbuf   
 *
 * call port function #_TCPF_#
 * require port : signature: sKernel context: task
 *   ER             sleep( );
 *   ER             sleepTimeout( TMO timeout );
 *   ER             delay( RELTIM delayTime );
 *   ER             exitTask( );
 *   ER             getTaskId( ID* p_taskId );
 *   ER             rotateReadyQueue( PRI taskPriority );
 *   ER             getTime( SYSTIM* p_systemTime );
 *   ER             getMicroTime( SYSUTM* p_systemMicroTime );
 *   ER             lockCpu( );
 *   ER             unlockCpu( );
 *   ER             disableDispatch( );
 *   ER             enableDispatch( );
 *   ER             disableTaskException( );
 *   ER             enableTaskException( );
 *   ER             changeInterruptPriorityMask( PRI interruptPriority );
 *   ER             getInterruptPriorityMask( PRI* p_interruptPriority );
 *   ER             exitKernel( );
 *   bool_t         senseContext( );
 *   bool_t         senseLock( );
 *   bool_t         senseDispatch( );
 *   bool_t         senseDispatchPendingState( );
 *   bool_t         senseKernel( );
 * call port : cUDPOutput  signature: sUDPOutput context: task
 *   ER             cUDPOutput_UDPOutput( const int8_t* outputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen, uint16_t dstport, uint16_t myport, T_OFF_BUF offset, TMO tmout );
 *   ER             cUDPOutput_getOffset( T_OFF_BUF* offset );
 * call port : cGetAddress  signature: sGetAddress context: task
 *   int8_t*        cGetAddress_getAddress( );
 * call port : cDataqueue  signature: sDataqueue context: task
 *   ER             cDataqueue_send( intptr_t data );
 *   ER             cDataqueue_sendPolling( intptr_t data );
 *   ER             cDataqueue_sendTimeout( intptr_t data, TMO timeout );
 *   ER             cDataqueue_sendForce( intptr_t data );
 *   ER             cDataqueue_receive( intptr_t* p_data );
 *   ER             cDataqueue_receivePolling( intptr_t* p_Data );
 *   ER             cDataqueue_receiveTimeout( intptr_t* p_data, TMO timeout );
 *   ER             cDataqueue_initialize( );
 *   ER             cDataqueue_refer( T_RDTQ* pk_dataqueueStatus );
 * call port : cSemaphore  signature: sSemaphore context: task
 *   ER             cSemaphore_signal( );
 *   ER             cSemaphore_wait( );
 *   ER             cSemaphore_waitPolling( );
 *   ER             cSemaphore_waitTimeout( TMO timeout );
 *   ER             cSemaphore_initialize( );
 *   ER             cSemaphore_refer( T_RSEM* pk_semaphoreStatus );
 * call port : cSemaphoreAllCEP  signature: sSemaphore context: task
 *   ER             cSemaphoreAllCEP_signal( );
 *   ER             cSemaphoreAllCEP_wait( );
 *   ER             cSemaphoreAllCEP_waitPolling( );
 *   ER             cSemaphoreAllCEP_waitTimeout( TMO timeout );
 *   ER             cSemaphoreAllCEP_initialize( );
 *   ER             cSemaphoreAllCEP_refer( T_RSEM* pk_semaphoreStatus );
 * call port : cCallingSendTask  signature: sTask context: task
 *   ER             cCallingSendTask_activate( );
 *   ER_UINT        cCallingSendTask_cancelActivate( );
 *   ER             cCallingSendTask_terminate( );
 *   ER             cCallingSendTask_changePriority( PRI priority );
 *   ER             cCallingSendTask_getPriority( PRI* p_priority );
 *   ER             cCallingSendTask_refer( T_RTSK* pk_taskStatus );
 *   ER             cCallingSendTask_wakeup( );
 *   ER_UINT        cCallingSendTask_cancelWakeup( );
 *   ER             cCallingSendTask_releaseWait( );
 *   ER             cCallingSendTask_suspend( );
 *   ER             cCallingSendTask_resume( );
 *   ER             cCallingSendTask_raiseException( TEXPTN pattern );
 * call port : cCallingReceiveTask  signature: sTask context: task
 *   ER             cCallingReceiveTask_activate( );
 *   ER_UINT        cCallingReceiveTask_cancelActivate( );
 *   ER             cCallingReceiveTask_terminate( );
 *   ER             cCallingReceiveTask_changePriority( PRI priority );
 *   ER             cCallingReceiveTask_getPriority( PRI* p_priority );
 *   ER             cCallingReceiveTask_refer( T_RTSK* pk_taskStatus );
 *   ER             cCallingReceiveTask_wakeup( );
 *   ER_UINT        cCallingReceiveTask_cancelWakeup( );
 *   ER             cCallingReceiveTask_releaseWait( );
 *   ER             cCallingReceiveTask_suspend( );
 *   ER             cCallingReceiveTask_resume( );
 *   ER             cCallingReceiveTask_raiseException( TEXPTN pattern );
 * allocator port for call port: eInput func: sendData param: input
 *   ER             eInput_sendData_input_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eInput_sendData_input_dealloc( const void* buf );
 *   ER             eInput_sendData_input_reuse( void* buf );
 *   ER_UINT        eInput_sendData_input_bufferSize( const void* buf );
 *   uint32_t       eInput_sendData_input_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tUDPCEP_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif



//temp 動的タスク結合をサポートする処理
//本当はカーネルの機能に組み込むがmikan

extern ER		get_inf(intptr_t *p_exinf);

typedef struct tag_tTask_VCB {
    /* call port #_TCP_# */ 
    intptr_t cBody;
    intptr_t cExceptionBody;
    /* call port #_NEP_# */ 
    /* attribute #_AT_# */ 
    ID             id;
    intptr_t       sTask_DES;
    intptr_t       siTask_DES;
}  tTask_VCB;

static struct tag_sTask_VDES*
get_tTask_DES()
{
	intptr_t inf;
	tTask_VCB *vcb;

	get_inf(&inf);
	vcb = (tTask_VCB*)inf;

	return (struct tag_sTask_VDES*)(vcb->sTask_DES);
}



#define tUDPCEP_cCallingSendTask_bind(p_that) ¥
  (p_that)->cCallingSendTask = get_tTask_DES()
#define cCallingSendTask_bind() tUDPCEP_cCallingSendTask_bind(p_cellcb)

#define tUDPCEP_cCallingReceiveTask_bind(p_that) ¥
  (p_that)->cCallingReceiveTask = get_tTask_DES()
#define cCallingReceiveTask_bind() tUDPCEP_cCallingReceiveTask_bind(p_cellcb)

//temp ここまで

//keisoku----
//#define cCallingSendTask_bind() 
//#define cCallingReceiveTask_bind()
//---keisoku

static uint16_t udp_port_auto = UDP_PORT_FIRST_AUTO;

/*
 *  udp_alloc_auto_port -- 自動割り当てポート番号を設定する。
 */

static ER
udp_alloc_auto_port (CELLCB	*p_cellcb)
{
	CELLCB	*p_cb;

	p_cb = p_cellcb;

	int_t	ix;
	uint16_t	portno, portno_start;

	portno_start = udp_port_auto;
	do {
		portno = udp_port_auto ++;
		if (udp_port_auto > UDP_PORT_LAST_AUTO)
		  udp_port_auto = UDP_PORT_FIRST_AUTO;
		
		cSemaphoreAllCEP_wait();
FOREACH_CELL(ix,p_cellcb)
		  if(VAR_myport == portno){
			  portno =UDP_PORTANY;
			  break;
		  }
END_FOREACH_CELL
		p_cellcb = p_cb;

		if (portno != UDP_PORTANY) {
			VAR_myport = portno;
			cSemaphoreAllCEP_signal();
			return E_OK;
		}
		cSemaphoreAllCEP_signal();

	} while (portno_start != udp_port_auto);

	return E_NOID;
}

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eInput
 * entry port: eInput
 * signature:  sUDPCEPInput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eInput_receiveTaskID
 * name:         eInput_receiveTaskID
 * global_name:  tUDPCEP_eInput_receiveTaskID
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ID
eInput_receiveTaskID(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	return VAR_receiveTaskID;

}

/* #[<ENTRY_FUNC>]# eInput_check
 * name:         eInput_check
 * global_name:  tUDPCEP_eInput_check
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eInput_check(CELLIDX idx, const int8_t* dstaddr, int32_t len, uint16_t dstport)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	//v4とv6でCEPを共通にする可能性を考慮してIF分
	if(ATTR_ipLength == len){
		if(dstport == VAR_myport){
			if(len ==4){
				if(*((T_IN4_ADDR *)dstaddr) == (*(T_IN4_ADDR *)cGetAddress_getAddress()))
				  return E_OK;
				if(*((T_IN4_ADDR *)dstaddr) == IPV4_ADDR_BROADCAST)
				  return E_OK;
			}
		}
	}

	return E_ID;
}

/* #[<ENTRY_FUNC>]# eInput_sendData
 * name:         eInput_sendData
 * global_name:  tUDPCEP_eInput_sendData
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eInput_sendData(CELLIDX idx, int8_t* input, int32_t size)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */

	ercd = cDataqueue_sendPolling((intptr_t)input);

	return(ercd);
}

/* #[<ENTRY_PORT>]# eAPI
 * entry port: eAPI
 * signature:  sUDPCEPAPI
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eAPI_send
 * name:         eAPI_send
 * global_name:  tUDPCEP_eAPI_send
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER_UINT
eAPI_send(CELLIDX idx, const int8_t* data, int32_t len, const int8_t* dstaddr, int32_t addrlen, uint16_t dstport, TMO tmout)
{
	ER		error = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */

	/* p_dstaddr または data が NULL か、tmout が TMO_NBLK ならエラー */
	if (dstaddr == NULL || data == NULL || tmout == TMO_NBLK)
		return E_PAR;

	int ip_hdr_size,if_mtu;
	
	//利用する下位プロトコルを決定する//offmikan
	VAR_offset.protocolflag = FLAG_USE_UDP;
	if(ATTR_ipLength == 4){
		VAR_offset.protocolflag |= FLAG_USE_IPV4;
	}
	else if(ATTR_ipLength == 6)
	  VAR_offset.protocolflag |= FLAG_USE_IPV6;
	else
	  return E_ID;
	if((error = cUDPOutput_getOffset(&VAR_offset)) != E_OK)
	  return error;
	if(VAR_offset.protocolflag & FLAG_USE_ETHER)
	  if_mtu = ETHER_MTU;


	/* データ長をチェックする。*/
	if (len < 0 || len + VAR_offset.iphdrlen + UDP_HDR_SIZE > if_mtu)
		return E_PAR;


	/*
	 *  自ポート番号が UDP_PORTANY なら、自動で割り当てる。
	 */
	if (VAR_myport == UDP_PORTANY) {
		if ((error = udp_alloc_auto_port(idx)) != E_OK)
		  return error;
	}
	   
	   
	/* 通信端点をロックする。*/
	cSemaphore_wait();

	   
	if (VAR_sendTaskID != TA_NULL) {

		/* 非ノンブロッキングコールでペンディング中 */
		error = E_QOVR;

		/* 通信端点をロックを解除する。*/
		cSemaphore_signal();
	}
	else {
		/* 現在のタスク識別子を記録する。*/
		getTaskId(&VAR_sendTaskID);

		/* タスクセルと動的結合する */
		cCallingSendTask_bind();

		/* 通信端点をロックを解除する。*/
		cSemaphore_signal();

		/* パケットを送信する。*/
		error = cUDPOutput_UDPOutput(data, len,dstaddr,cGetAddress_getAddress(),addrlen,dstport,VAR_myport,VAR_offset,tmout );
		VAR_sendTaskID = TA_NULL;

	}

	return error;
}

/* #[<ENTRY_FUNC>]# eAPI_receive
 * name:         eAPI_receive
 * global_name:  tUDPCEP_eAPI_receive
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER_UINT
eAPI_receive(CELLIDX idx, int8_t* data, int32_t len, TMO tmout)
{
	ER_UINT error;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	T_NET_BUF *input;
	T_UDP_HDR	*udph;
	uint32_t		ulen, uhoff;

	/* p_dstaddr または data が NULL 、len < 0 か、tmout が TMO_NBLK ならエラー */
	//mikan とりあえずノンブロッキングコールには対応しない
	if (data == NULL || len < 0 || tmout == TMO_NBLK)
		return E_PAR;
	
	/* 通信端点をロックする。*/
	cSemaphore_wait();

	if (VAR_receiveTaskID != TA_NULL) {

		/* 非ノンブロッキングコールでペンディング中 */
		error = E_QOVR;

		/* 通信端点をロックを解除する。*/
		cSemaphore_signal();
	}
	else {
		getTaskId(&VAR_receiveTaskID);

		/* タスクを動的結合する */
		cCallingReceiveTask_bind();

		//通信端点のロックを解除する
		cSemaphore_signal();

		if(VAR_cb_netbuf != NULL) {

			/*
			 *  ここにくる場合は、コールバック関数の中から
			 *  udp_rcv_dat を呼び出していることになり、
			 *  すでに入力済みである。
			 */
			input = VAR_cb_netbuf;
			VAR_cb_netbuf = NULL;
		}
		else if ((error = cDataqueue_receiveTimeout((intptr_t*)&input, tmout)) != E_OK) {


			VAR_receiveTaskID = TA_NULL;
			return error;
		}

		if(!(VAR_offset.protocolflag & FLAG_USE_UDP))
			VAR_offset = input->off;

		//mikan 宛先IPとポート番号は未実装
		/* データをバッファに移す。*/
		udph = GET_UDP_HDR(input,input->off.ifhdrlen+input->off.iphdrlenall);
		ulen = ntohs(udph->ulen);
		if (ulen - UDP_HDR_SIZE > len)
			error = E_BOVR;
		else {
			len   =    (uint32_t)(ulen - UDP_HDR_SIZE);
			error = (ER_UINT)(ulen - UDP_HDR_SIZE);
		}

		
		memcpy(data, (uint8_t *)(udph+UDP_HDR_SIZE), (size_t)len);

		eInput_sendData_input_dealloc((void*)input);

		VAR_receiveTaskID = TA_NULL;
		}

	return error;

}

/* #[<ENTRY_FUNC>]# eAPI_cancelSend
 * name:         eAPI_cancelSend
 * global_name:  tUDPCEP_eAPI_cancelSend
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eAPI_cancelSend(CELLIDX idx, ER error)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */

	if(VAR_sendTaskID != TA_NULL){

		ercd = cCallingSendTask_releaseWait();
		VAR_sendTaskID = TA_NULL;
	}
	else
	  ercd = EV_NOPND;

	return(ercd);
}

/* #[<ENTRY_FUNC>]# eAPI_celcelReceive
 * name:         eAPI_celcelReceive
 * global_name:  tUDPCEP_eAPI_celcelReceive
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eAPI_celcelReceive(CELLIDX idx, ER error)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	if(VAR_receiveTaskID != TA_NULL){

		ercd = cCallingReceiveTask_releaseWait();
		VAR_receiveTaskID = TA_NULL;
	}
	else
	  ercd = EV_NOPND;

	return(ercd);
}

/* #[<ENTRY_PORT>]# eCallback
 * entry port: eCallback
 * signature:  sUDPCallback
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eCallback_callback
 * name:         eCallback_callback
 * global_name:  tUDPCEP_eCallback_callback
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eCallback_callback(CELLIDX idx, FN fncd, ER_UINT error)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */

	//TEV_UDP_RCV_DATのケースでは必ずメモリを解放する

}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
