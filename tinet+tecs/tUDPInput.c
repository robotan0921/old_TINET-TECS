/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tUDPInput_template.c => src/tUDPInput.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * #[<...>]# から #[</...>]# で囲まれたコメントは編集しないでください
 * tecsmerge によるマージに使用されます
 *
 * 呼び口関数 #_TCPF_#
 * call port: cCEPInput signature: sUDPCEPInput context:task
 *   ID             cCEPInput_receiveTaskID( subscript );
 *   ER             cCEPInput_check( subscript, const int8_t* dstaddr, int32_t len, uint16_t dstport );
 *   ER             cCEPInput_sendData( subscript, int8_t* input, int32_t size );
 *       subscript:  0...(NCP_cCEPInput-1)
 * call port: cCallback signature: sUDPCallback context:task optional:true
 *   bool_t     is_cCallback_joined(int subscript)        check if joined
 *   void           cCallback_callback( subscript, FN fncd, ER_UINT error );
 *       subscript:  0...(NCP_cCallback-1)
 * call port: cICMP4Error signature: sICMP4Error context:task optional:true
 *   bool_t     is_cICMP4Error_joined()                     check if joined
 *   void           cICMP4Error_error( int8_t* inputp, int32_t size, uint8_t code );
 * call port: cIPv4CheckSum signature: sIPv4CheckSum context:task optional:true
 *   bool_t     is_cIPv4CheckSum_joined()                     check if joined
 *   uint16_t       cIPv4CheckSum_ipv4CheckSum( int8_t* data, int32_t size, uint32_t offset, uint8_t proto );
 * allocator port for call port:cCEPInput func:sendData param: input
 *   ER             cCEPInput_sendData_input_alloc( subscript, void** buf, const int32_t minlen, TMO tmout );
 *   ER             cCEPInput_sendData_input_dealloc( subscript, const void* buf );
 *   ER             cCEPInput_sendData_input_reuse( subscript, void* buf );
 *   ER_UINT        cCEPInput_sendData_input_bufferSize( subscript, const void* buf );
 *   uint32_t       cCEPInput_sendData_input_bufferMaxSize( subscript );
 *       subscript:  0...(NCP_cCEPInput_sendData_input-1)
 * allocator port for call port:cICMP4Error func:error param: inputp
 *   ER             cICMP4Error_error_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cICMP4Error_error_inputp_dealloc( const void* buf );
 *   ER             cICMP4Error_error_inputp_reuse( void* buf );
 *   ER_UINT        cICMP4Error_error_inputp_bufferSize( const void* buf );
 *   uint32_t       cICMP4Error_error_inputp_bufferMaxSize( );
 * allocator port for call port:eInput func:UDPInput param: inputp
 *   ER             eInput_UDPInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eInput_UDPInput_inputp_dealloc( const void* buf );
 *   ER             eInput_UDPInput_inputp_reuse( void* buf );
 *   ER_UINT        eInput_UDPInput_inputp_bufferSize( const void* buf );
 *   uint32_t       eInput_UDPInput_inputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tUDPInput_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eInput
 * entry port: eInput
 * signature:  sUDPInput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eInput_UDPInput
 * name:         eInput_UDPInput
 * global_name:  tUDPInput_eInput_UDPInput
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
uint32_t
eInput_UDPInput(int8_t* inputp, int32_t size, const int8_t* dstaddr, int32_t addrlen)
{
	/* Put statements here #_TEFB_# */

	T_NET_BUF *input =(T_NET_BUF *)inputp;
	int32_t		ix;
	uint32_t		len, hlen, ulen;
	uint32_t offset = input->off.ifhdrlen + input->off.iphdrlenall;

	input->off.protocolflag |= FLAG_USE_UDP;
	input->off.tphdrlen = UDP_HDR_SIZE;
	input->off.tphdrlenall = UDP_HDR_SIZE;
	
	/* ヘッダ長をチェックする。*/
	if (input->len < offset + UDP_HDR_SIZE)
		goto buf_rel;

	T_UDP_HDR *udph = GET_UDP_HDR(input,offset);

	/* データグラム長をチェックする */
	ulen  = ntohs(udph->ulen);
	if (ulen != input->len - offset+input->off.ifalign)
		goto buf_rel;

	/* 宛先ポートが 0 のデータグラムは破棄する。RFC768 */
	if (udph->dport == 0)
		goto buf_rel;



	/* チェックサムをチェックする */
	if((input->off.protocolflag & FLAG_USE_IPV4) && is_cIPv4CheckSum_joined()){
		if (udph->sum && cIPv4CheckSum_ipv4CheckSum(inputp,size,offset, IPPROTO_UDP) != 0)
		  goto buf_rel;
	}


	for(ix = N_CP_cCEPInput;ix -- > 0; ) {
		if(cCEPInput_check(ix,dstaddr,addrlen,ntohs(udph->dport)) == E_OK){

			len = (uint32_t)(ntohs(udph->ulen) - UDP_HDR_SIZE);

			if(cCEPInput_receiveTaskID(ix) != TA_NULL) {
				if(cCEPInput_sendData(ix,inputp,size) != E_OK)
				  goto buf_rel;
			}
			
			
			//mikan UDPのノンブロッキングコールをサポートするならばの処理


			
			else if(is_cCallback_joined(ix))  {

				//コールバックで勝手にバッファを解放する場合はとかそういう処理が入るのですが、
				//難易度が高いので先送っちゃうのでかってに解放して下さいということにする
				if(cCEPInput_sendData(ix,inputp,size) != E_OK)
				  goto buf_rel;
				cCallback_callback(ix,TEV_UDP_RCV_DAT,len);
			}
			else
			  goto buf_rel;

			return IPPROTO_DONE;
		}
	}


	//該当CEPがなかった場合のエラー処理は下位プロトコルにコールバックで依頼する
	if((input->off.protocolflag & FLAG_USE_IPV4) && is_cICMP4Error_joined())
		cICMP4Error_error(inputp,size,ICMP4_UNREACH_PORT);

	
buf_rel:
	eInput_UDPInput_inputp_dealloc((void*)inputp);//mikan どっちにしろ同じアロケータ利用を前提
	return IPPROTO_DONE;
}

/* #[<POSTAMBLE>]#
 *   これより下に非受け口関数を書きます
 * #[</POSTAMBLE>]#*/
