/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tTCPInput_template.c => src/tTCPInput.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * call port : cCEPInput  signature: sTCPCEPInput context: task
 *   ER             cCEPInput_check( subscript, const int8_t* dstaddr, const int8_t* srcaddr, int32_t len, uint16_t dstport, uint16_t srcport );
 *   ER             cCEPInput_input( subscript, int8_t* inputp, int32_t size );
 *   void           cCEPInput_notify( subscript, ER error );
 *       subscript:  0...(NCP_cCEPInput-1)
 * call port : cTCPRespond  signature: sTCPOutput context: task
 *   ER             cTCPRespond_output( int8_t* outputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen );
 *   ER             cTCPRespond_getOffset( T_OFF_BUF* offset );
 *   T_IN4_ADDR     cTCPRespond_getIPv4Address( );
 *   ER             cTCPRespond_respond( int8_t* outputp, int32_t size, T_TCP_CEP* cep, T_TCP_SEQ ack, T_TCP_SEQ seq, uint32_t rbfree, uint8_t flags );
 *   ER             cTCPRespond_allocAndRespond( const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen, uint16_t dstport, uint16_t srcport, T_TCP_SEQ ack, T_TCP_SEQ seq, uint32_t rbfree, uint8_t flags, T_OFF_BUF offset );
 * call port : cIPv4CheckSum  signature: sIPv4CheckSum context: task
 *   uint16_t       cIPv4CheckSum_ipv4CheckSum( int8_t* data, int32_t size, uint32_t offset, uint8_t proto );
 * allocator port for call port: cCEPInput func: input param: inputp
 *   ER             cCEPInput_input_inputp_alloc( subscript, void** buf, const int32_t minlen, TMO tmout );
 *   ER             cCEPInput_input_inputp_dealloc( subscript, const void* buf );
 *   ER             cCEPInput_input_inputp_reuse( subscript, void* buf );
 *   ER_UINT        cCEPInput_input_inputp_bufferSize( subscript, const void* buf );
 *   uint32_t       cCEPInput_input_inputp_bufferMaxSize( subscript );
 *       subscript:  0...(NCP_cCEPInput_input_inputp-1)
 * allocator port for call port: cTCPRespond func: output param: outputp
 *   ER             cTCPRespond_output_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cTCPRespond_output_outputp_dealloc( const void* buf );
 *   ER             cTCPRespond_output_outputp_reuse( void* buf );
 *   ER_UINT        cTCPRespond_output_outputp_bufferSize( const void* buf );
 *   uint32_t       cTCPRespond_output_outputp_bufferMaxSize( );
 * allocator port for call port: cTCPRespond func: respond param: outputp
 *   ER             cTCPRespond_respond_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cTCPRespond_respond_outputp_dealloc( const void* buf );
 *   ER             cTCPRespond_respond_outputp_reuse( void* buf );
 *   ER_UINT        cTCPRespond_respond_outputp_bufferSize( const void* buf );
 *   uint32_t       cTCPRespond_respond_outputp_bufferMaxSize( );
 * allocator port for call port: eInput func: TCPInput param: inputp
 *   ER             eInput_TCPInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eInput_TCPInput_inputp_dealloc( const void* buf );
 *   ER             eInput_TCPInput_inputp_reuse( void* buf );
 *   ER_UINT        eInput_TCPInput_inputp_bufferSize( const void* buf );
 *   uint32_t       eInput_TCPInput_inputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tTCPInput_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eInput
 * entry port: eInput
 * signature:  sTCPInput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eInput_TCPInput
 * name:         eInput_TCPInput
 * global_name:  tTCPInput_eInput_TCPInput
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
uint32_t
eInput_TCPInput(int8_t* inputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen)
{

	T_NET_BUF *input =(T_NET_BUF *)inputp;
	int32_t ix;
	T_TCP_HDR	*tcph;
	uint16_t seglen;
	int32_t offset;
	ER error;
	
	/*プロトコルフラグにTCPをセット */
	input->off.protocolflag |= FLAG_USE_TCP;
	input->off.tphdrlen = TCP_HDR_SIZE;
	offset = input->off.ifhdrlen + input->off.iphdrlenall;

	syslog(LOG_EMERG, "packet length = %d",input->len);
	syslog(LOG_EMERG, "ifhdrlen = %d",input->off.ifhdrlen);
	syslog(LOG_EMERG, "iphdrlenall = %d",input->off.iphdrlenall);
	
	/* ヘッダ長をチェックする。*/
	if (input->len < offset + TCP_HDR_SIZE -input->off.ifalign) {
		syslog(LOG_EMERG, "TCP packets are Droped about header length !");
		goto drop;
	}

	tcph = GET_TCP_HDR(input,offset);

	seglen  = input->len - (offset - input->off.ifalign);				/* TCP のセグメント長 */

	if((input->off.protocolflag & FLAG_USE_IPV4) && is_cIPv4CheckSum_joined()){
		if (cIPv4CheckSum_ipv4CheckSum(inputp,size,offset, IPPROTO_TCP) != 0){
			syslog(LOG_EMERG, "TCP packets are Droped when check sum!" );
			goto drop;
		}
	}

	/* TCP ヘッダ長をチェックする。*/
	if (TCP_HDR_LEN(tcph->doff) < TCP_HDR_SIZE || TCP_HDR_LEN(tcph->doff) > seglen) {
		syslog(LOG_EMERG, "TCP packets are Droped when length!");
		goto drop;
	}
	tcph->sum = seglen - TCP_HDR_LEN(tcph->doff);		/* ここから tcph->sum は TCP の SDU 長 */

	/*
	 *  SYN と FIN の両ビットがセットされていれば破棄する。nmap 等の対策
	 *  ただし、RFC1644 T/TCP 拡張機能と競合する。
	 */
	if ((tcph->flags & (TCP_FLG_SYN | TCP_FLG_FIN)) == (TCP_FLG_SYN | TCP_FLG_FIN)){
		syslog(LOG_EMERG, "TCP packets are Droped about flag!");
		goto drop;
	}
		
	/* ネットワークオーダーからホストオーダーに変換する。*/

	NTOHL(tcph->seq);
	NTOHL(tcph->ack);
	NTOHS(tcph->win);
	NTOHS(tcph->urp);
	NTOHS(tcph->sport);
	NTOHS(tcph->dport);



	/*TCPCEPのファインド*/
	for(ix=0;ix<N_CP_cCEPInput;ix++){
		if(cCEPInput_check(ix,dstaddr,srcaddr,addrlen, tcph->dport, tcph->sport) == E_OK){
			syslog(LOG_EMERG, "CEP FIND! seq :%d  ack:%d .",tcph->seq,tcph->ack);
			error = cCEPInput_input(ix,inputp,size);
			syslog(LOG_EMERG, "********success!*********");
			return error;
		}
	}

	/* CEPがなかった処理 */
	syslog(LOG_EMERG, "CEP Lost... seq :%d  ack:%d .",tcph->seq,tcph->ack);
	
	/*
	 *  RST 送信処理
	 */

	if(input->off.protocolflag & FLAG_USE_IPV4){
		if ((tcph->flags & TCP_FLG_RST) || IPV4_CLASS_D(*(T_IN4_ADDR *)dstaddr)){
			goto drop;
		}
	}

	/* ホストオーダーからネットワークオーダーに戻す。*/

	HTONS(tcph->sport);
	HTONS(tcph->dport);

	int32_t rbfree = 0;

	if (tcph->flags & TCP_FLG_ACK) {
		cTCPRespond_respond(inputp,size, NULL,0,tcph->ack,rbfree, TCP_FLG_RST);
	}
	else {
		if (tcph->flags & TCP_FLG_SYN)
		  tcph->sum ++;		/* tcph->sum は SDU 長 */
		cTCPRespond_respond(inputp,size,NULL,tcph->seq + tcph->sum,0,rbfree, TCP_FLG_RST | TCP_FLG_ACK);
	}
	
	syslog(LOG_EMERG,"*****************");
	/* input は tcp_respoond で返却される。*/
	return IPPROTO_DONE;
	
	
drop:
	eInput_TCPInput_inputp_dealloc(inputp);
	syslog(LOG_EMERG,"*******droped**********");
	return IPPROTO_DONE;	
}

/* #[<ENTRY_FUNC>]# eInput_TCPNotify
 * name:         eInput_TCPNotify
 * global_name:  tTCPInput_eInput_TCPNotify
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eInput_TCPNotify(const int8_t* inputp, int32_t size, ER error)
{
	T_IP4_HDR	*ip4h;
	T_TCP_HDR	*tcph;
	T_NET_BUF *input = (T_NET_BUF *)inputp;
	int addrlen,ix;
	T_IN4_ADDR dst,src;
	int8_t *dstaddr,*srcaddr;

	if(input->off.protocolflag & FLAG_USE_IPV4){
		ip4h  = GET_IP4_HDR(input,input->off.ifhdrlen);
		addrlen = 4;
		dst = ntohl(ip4h->dst);
		src = ntohl(ip4h->src);
		dstaddr = &dst;
		srcaddr = &src;
	}else{
	}
	tcph = GET_TCP_HDR(input, input->off.ifhdrlen + input->off.iphdrlenall);

	/*TCPCEPのファインド*/
	for(ix=0;ix<N_CP_cCEPInput;ix++){
		if(cCEPInput_check(ix,dstaddr,srcaddr,addrlen, tcph->dport, tcph->sport) == E_OK){
			cCEPInput_notify(ix,error);
			return;
		}
	}	
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
