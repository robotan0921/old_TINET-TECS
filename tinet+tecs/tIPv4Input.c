/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tIPv4Input_template.c => src/tIPv4Input.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * call port : cUDPInput  signature: sUDPInput context: task
 *   uint32_t       cUDPInput_UDPInput( int8_t* inputp, int32_t size, const int8_t* dstaddr, int32_t addrlen );
 * call port : cTCPInput  signature: sTCPInput context: task
 *   uint32_t       cTCPInput_TCPInput( int8_t* inputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen );
 *   void           cTCPInput_TCPNotify( const int8_t* inputp, int32_t size, ER error );
 * call port : cICMP4  signature: sICMP4Input context: task
 *   uint32_t       cICMP4_input( int8_t* inputp, int32_t size );
 * call port : cICMP4Error  signature: sICMP4Error context: task
 *   void           cICMP4Error_error( int8_t* inputp, int32_t size, uint8_t code );
 * call port : cFunctions  signature: sIPv4Functions context: task
 *   uint16_t       cFunctions_checkSum( const int8_t* data, uint32_t len );
 *   T_IN4_ADDR     cFunctions_getIPv4Address( );
 *   T_IN4_ADDR     cFunctions_getIPv4Mask( );
 * allocator port for call port: cUDPInput func: UDPInput param: inputp
 *   ER             cUDPInput_UDPInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cUDPInput_UDPInput_inputp_dealloc( const void* buf );
 *   ER             cUDPInput_UDPInput_inputp_reuse( void* buf );
 *   ER_UINT        cUDPInput_UDPInput_inputp_bufferSize( const void* buf );
 *   uint32_t       cUDPInput_UDPInput_inputp_bufferMaxSize( );
 * allocator port for call port: cTCPInput func: TCPInput param: inputp
 *   ER             cTCPInput_TCPInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cTCPInput_TCPInput_inputp_dealloc( const void* buf );
 *   ER             cTCPInput_TCPInput_inputp_reuse( void* buf );
 *   ER_UINT        cTCPInput_TCPInput_inputp_bufferSize( const void* buf );
 *   uint32_t       cTCPInput_TCPInput_inputp_bufferMaxSize( );
 * allocator port for call port: cICMP4 func: input param: inputp
 *   ER             cICMP4_input_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cICMP4_input_inputp_dealloc( const void* buf );
 *   ER             cICMP4_input_inputp_reuse( void* buf );
 *   ER_UINT        cICMP4_input_inputp_bufferSize( const void* buf );
 *   uint32_t       cICMP4_input_inputp_bufferMaxSize( );
 * allocator port for call port: cICMP4Error func: error param: inputp
 *   ER             cICMP4Error_error_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cICMP4Error_error_inputp_dealloc( const void* buf );
 *   ER             cICMP4Error_error_inputp_reuse( void* buf );
 *   ER_UINT        cICMP4Error_error_inputp_bufferSize( const void* buf );
 *   uint32_t       cICMP4Error_error_inputp_bufferMaxSize( );
 * allocator port for call port: eIPv4Input func: IPv4Input param: inputp
 *   ER             eIPv4Input_IPv4Input_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eIPv4Input_IPv4Input_inputp_dealloc( const void* buf );
 *   ER             eIPv4Input_IPv4Input_inputp_reuse( void* buf );
 *   ER_UINT        eIPv4Input_IPv4Input_inputp_bufferSize( const void* buf );
 *   uint32_t       eIPv4Input_IPv4Input_inputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tIPv4Input_tecsgen.h"
#include "kernel.h"//keisoku

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eIPv4Input
 * entry port: eIPv4Input
 * signature:  sIPv4Input
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eIPv4Input_IPv4Input
 * name:         eIPv4Input_IPv4Input
 * global_name:  tIPv4Input_eIPv4Input_IPv4Input
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eIPv4Input_IPv4Input(CELLIDX idx, int8_t* inputp, int32_t size)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	T_NET_BUF *input = (T_NET_BUF*)inputp;

	//バッファ情報のセット
	input->off.protocolflag |= FLAG_USE_IPV4;
	input->off.iphdrlen = IP4_HDR_SIZE;
	input->off.ipmss = TCP_MSS;

	T_IP4_HDR *ip4h = GET_IP4_HDR(input,input->off.ifhdrlen);
	uint32_t hlen = GET_IP4_HDR_SIZE(ip4h);
	input->off.iphdrlenall = hlen;

	/* ネットワークバッファの長さをデータグラム長に調整する。*/
	//コントローラに不調があるケースのためにここで改めて設定する
	input->len = (uint16_t)(ntohs(ip4h->len) + input->off.ifhdrlen - input->off.ifalign);
	size = input->len +sizeof(T_NET_BUF) - 4;

	/* IP ヘッダの長さをチェックする。*/
	if (input->len < IP4_HDR_SIZE+input->off.ifhdrlen -input->off.ifalign)
	  goto buf_rel;
	
	/* バージョンをチェックする。*/
	if (IP4_VHL_V(ip4h->vhl) != IPV4_VERSION) {
		goto buf_rel;
	}

	/* IP ヘッダの長さをチェックし、オプションを解析する。*/
	if (hlen > IP4_HDR_SIZE) {
		/* %%% オプションの解析 %%% */
	}
	
	/* データグラム長をチェックする。*/
	if (ntohs(ip4h->len) > input->len - input->off.ifhdrlen + input->off.ifalign) {
		goto buf_rel;
	}
	

	/* チェックサムをチェックする。*/
	if (cFunctions_checkSum(ip4h, hlen) != 0) {
		goto buf_rel;
	}

	/* IP ヘッダの長さをチェックし、上位が ICMP 以外はオプションを消去する。*/
	if (hlen > IP4_HDR_SIZE && ip4h->proto != IPPROTO_ICMP) {
		memset((uint8_t*)ip4h + IP4_HDR_SIZE, 0, hlen - IP4_HDR_SIZE);
	}

	T_IN4_ADDR src,dst,bc;
	T_IN4_ADDR addr=cFunctions_getIPv4Address();
	T_IN4_ADDR mask=cFunctions_getIPv4Mask();

	/* 送信元アドレスをチェックする。*/
	src = ntohl(ip4h->src);
	bc  = (addr & mask) | ~mask;

	//
	//**************   LOOPだったらどうだとかそういう処理が入る
	//mikan これどうしよう
	if (src == addr || src == bc || src == IPV4_ADDR_BROADCAST || src == IPV4_ADDRANY) {
		goto buf_rel;
	}

	
	/* あて先アドレスをチェックする。*/
	dst = ntohl(ip4h->dst);

	syslog(LOG_EMERG,"IPv4 input dst is %d ~~~ %d",(0xFF & ip4h->dst),ip4h->dst>>24 );

	
	//
	//************** IP送信アドレスの判定
	//mikan とりあえずDHCPないならば処理

	if ((addr != IPV4_ADDRANY) &&
	    (!(dst == addr || dst == bc ||
	       dst == IPV4_ADDR_BROADCAST || dst == IPV4_ADDRANY))) {
		goto buf_rel;
	}

	//
	//**************  IP分割機能がONだったらどうだとかそういう処理が入る
	//mikan とりあえずない

	/* 分割されているかチェックする。*/
	if (ntohs(ip4h->flg_off) & (IP4_MF | IP4_OFFMASK)) {
		T_IN4_ADDR	src;
		
		if ((ntohs(ip4h->flg_off) & IP4_OFFMASK) == 0) {
		}
		syslog(LOG_EMERG, "[IP] FRAGMENT function is not supported");
		goto buf_rel;
	}

	//uint32_t off  = (uint32_t)hlen+input->ifhdrlen;

	//syslog(LOG_EMERG, "receive IP address is %x",dst);


	//mikan IPsecの処理

	//dis_int(0x200);//keisoku
	//wai_sem(8);//keisoku

	
	/* プロトコルを選択する */
	switch (ip4h->proto) {

	  case IPPROTO_UDP:
		if(is_cUDPInput_joined()){
			if(dst == bc)
			  dst = IPV4_ADDR_BROADCAST;
			cUDPInput_UDPInput(inputp,size, (int8_t *)&dst,4 );//dstはホストオーダ順で入っている[0]=200 [1]=1 [2]=168 [3]=192//offmikan
			return;
		}
		break;
		
	  case IPPROTO_TCP:
		if(is_cTCPInput_joined()){
			syslog(LOG_EMERG,"*********TCP INPUT ENTRY ********* ");
			cTCPInput_TCPInput(inputp,size,(int8_t*)&dst,(int8_t*)&src,4);
			return;
		}
		break;
		
	  case IPPROTO_ICMP:
		if(is_cICMP4_joined()){
			cICMP4_input(inputp,size);
			return;
		}
		break;

	  default:
		/* ローカル IP アドレスに届いたデータグラムのみ ICMP エラーを通知する。*/
		if ((dst == addr) && is_cICMP4Error_joined()) {
			T_IN4_ADDR	src;

			src = ntohl(ip4h->src);
			syslog(LOG_EMERG, "[IP] unexp proto: %d, src=%d.", ip4h->proto, src);
			cICMP4Error_error(inputp,size,ICMP4_UNREACH_PROTOCOL);
		}
		break;
	}
		
	
buf_rel:
	eIPv4Input_IPv4Input_inputp_dealloc( (void*)inputp );
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
