/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tICMP4_template.c => src/tICMP4.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * call port : cTCPInput  signature: sTCPInput context: task
 *   uint32_t       cTCPInput_TCPInput( int8_t* inputp, int32_t size, const int8_t* dstaddr, const int8_t* srcaddr, int32_t addrlen );
 *   void           cTCPInput_TCPNotify( const int8_t* inputp, int32_t size, ER error );
 * call port : cIPv4Reply  signature: sIPv4Output context: task
 *   ER             cIPv4Reply_IPv4Output( int8_t* outputp, int32_t size, TMO tmout );
 *   ER             cIPv4Reply_getOffset( T_OFF_BUF* offset );
 *   T_IN4_ADDR     cIPv4Reply_getIPv4Address( );
 *   void           cIPv4Reply_setHeader( int8_t* outputp, int32_t size, T_IN4_ADDR dstaddr, T_IN4_ADDR srcaddr );
 *   ER             cIPv4Reply_IPv4Reply( int8_t* outputp, int32_t size, TMO tmout );
 * call port : cIPv4Functions  signature: sIPv4Functions context: task
 *   uint16_t       cIPv4Functions_checkSum( const int8_t* data, uint32_t len );
 *   T_IN4_ADDR     cIPv4Functions_getIPv4Address( );
 *   T_IN4_ADDR     cIPv4Functions_getIPv4Mask( );
 * allocator port for call port: cTCPInput func: TCPInput param: inputp
 *   ER             cTCPInput_TCPInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cTCPInput_TCPInput_inputp_dealloc( const void* buf );
 *   ER             cTCPInput_TCPInput_inputp_reuse( void* buf );
 *   ER_UINT        cTCPInput_TCPInput_inputp_bufferSize( const void* buf );
 *   uint32_t       cTCPInput_TCPInput_inputp_bufferMaxSize( );
 * allocator port for call port: cIPv4Reply func: IPv4Output param: outputp
 *   ER             cIPv4Reply_IPv4Output_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cIPv4Reply_IPv4Output_outputp_dealloc( const void* buf );
 *   ER             cIPv4Reply_IPv4Output_outputp_reuse( void* buf );
 *   ER_UINT        cIPv4Reply_IPv4Output_outputp_bufferSize( const void* buf );
 *   uint32_t       cIPv4Reply_IPv4Output_outputp_bufferMaxSize( );
 * allocator port for call port: cIPv4Reply func: IPv4Reply param: outputp
 *   ER             cIPv4Reply_IPv4Reply_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cIPv4Reply_IPv4Reply_outputp_dealloc( const void* buf );
 *   ER             cIPv4Reply_IPv4Reply_outputp_reuse( void* buf );
 *   ER_UINT        cIPv4Reply_IPv4Reply_outputp_bufferSize( const void* buf );
 *   uint32_t       cIPv4Reply_IPv4Reply_outputp_bufferMaxSize( );
 * allocator port for call port: eICMP4 func: input param: inputp
 *   ER             eICMP4_input_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eICMP4_input_inputp_dealloc( const void* buf );
 *   ER             eICMP4_input_inputp_reuse( void* buf );
 *   ER_UINT        eICMP4_input_inputp_bufferSize( const void* buf );
 *   uint32_t       eICMP4_input_inputp_bufferMaxSize( );
 * allocator port for call port: eICMP4Error func: error param: inputp
 *   ER             eICMP4Error_error_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eICMP4Error_error_inputp_dealloc( const void* buf );
 *   ER             eICMP4Error_error_inputp_reuse( void* buf );
 *   ER_UINT        eICMP4Error_error_inputp_bufferSize( const void* buf );
 *   uint32_t       eICMP4Error_error_inputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tICMP4_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif




/*
 *  icmp_echo -- エコー要求を受信したときの処理
 *
 *    input には IF ヘッダと IP ヘッダも含まれている。
 */

static void
icmp_echo (CELLCB *p_cellcb,T_NET_BUF *input,int32_t size)
{
	
	T_IP4_HDR	*ip4h;
	T_ICMP4_HDR	*icmp4h;
	T_IN4_ADDR	srcaddr,dstaddr;
	int32_t icmpoff;

	/* IP ヘッダの宛先と発信元を交換する。*/
	ip4h      = GET_IP4_HDR(input,input->off.ifhdrlen);
	srcaddr      = ip4h->src;
	ip4h->src = ip4h->dst;
	dstaddr = ntohl(ip4h->dst);
	ip4h->dst = srcaddr;
	srcaddr = ntohl(srcaddr);
	
	/* メッセージの型をエコー要求 (8) から エコー応答 (0) に	*/
	/* 変更して送り返す。					*/

	icmpoff = input->off.ifhdrlen + GET_IP4_HDR_SIZE(ip4h);

	icmp4h = GET_ICMP4_HDR(input, icmpoff);
	icmp4h->type = ICMP4_ECHO_REPLY;

	/* チェックサムを計算する。*/
	icmp4h->sum = 0;
	icmp4h->sum = cIPv4Functions_checkSum(icmp4h,(uint_t)(((input->len +input->off.ifalign- icmpoff)) + 3) >> 2 << 2);

	/* 送信する。*/
	cIPv4Reply_IPv4Reply((int8_t*)input,size,TMO_ICMP_OUTPUT);
}

/*
 *  icmp_unreach -- ICMP4_UNREACH を受信したときの処理
 */

static const int8_t code2error[] = {
	EV_HURCH,	/* ICMP4_UNREACH_NET			 0 */
	EV_HURCH,	/* ICMP4_UNREACH_HOST			 1 */
	EV_CNNRF,	/* ICMP4_UNREACH_PROTOCOL		 2 */
	EV_CNNRF,	/* ICMP4_UNREACH_PORT			 3 */
	EV_MSIZE,	/* ICMP4_UNREACH_FLAG			 4 */
	EV_HURCH,	/* ICMP4_UNREACH_SRC_FAIL		 5 */
	EV_HURCH,	/* ICMP4_UNREACH_NET_UNKNOWN		 6 */
	EV_HURCH,	/* ICMP4_UNREACH_HOST_UNKNOWN		 7 */
	EV_HURCH,	/* ICMP4_UNREACH_ISOLATED		 8 */
	EV_HURCH,	/* ICMP4_UNREACH_NET_PROHIB		 9 */
	EV_HURCH,	/* ICMP4_UNREACH_HOST_PROHIB		10 */
	EV_HURCH,	/* ICMP4_UNREACH_TOS_NET		11 */
	EV_HURCH,	/* ICMP4_UNREACH_TOS_HOST		12 */
	EV_HURCH,	/* ICMP4_UNREACH_FILTER_PROHIB		13 */
	EV_HURCH,	/* ICMP4_UNREACH_HOST_PRECEDENCE	14 */
	EV_HURCH,	/* ICMP4_UNREACH_PRECEDENCE_CUTOFF	15 */
	};


static void
icmp_unreach (CELLCB *p_cellcb,T_NET_BUF *input,int32_t size)
{
	T_IP4_HDR	*ip4h;
	uint8_t		code;
	ER error;
	
	ip4h      = (T_IP4_HDR*)GET_ICMP4_SDU(input, input->off.ifhdrlen + input->off.iphdrlenall);
	int32_t icmpoff = input->off.ifhdrlen + GET_IP4_HDR_SIZE(ip4h);

	code  = GET_ICMP4_HDR(input, icmpoff)->code;
	error = code2error[code];
	if (ip4h->proto == IPPROTO_TCP) {

		//TCPがあればmikan
		if(is_cTCPInput_joined()){

			memcpy(GET_IP4_HDR(input,input->off.ifhdrlen), ip4h, input->len + input->off.ifalign - (IP4_HDR_SIZE + ICMP4_HDR_SIZE));
			input->len -= IP4_HDR_SIZE + ICMP4_HDR_SIZE;
			cTCPInput_TCPNotify(input,input->len +sizeof(T_NET_BUF), error);
		}

	}
	else
	  syslog(LOG_NOTICE, "[ICMP] error, code: %d.", code);
}


/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eICMP4
 * entry port: eICMP4
 * signature:  sICMP4Input
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eICMP4_input
 * name:         eICMP4_input
 * global_name:  tICMP4_eICMP4_input
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
uint32_t
eICMP4_input(CELLIDX idx, int8_t* inputp, int32_t size)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	T_NET_BUF *input =(T_NET_BUF*)inputp;
	T_ICMP4_HDR *icmp4h;
	T_IP4_HDR *iph = GET_IP4_HDR(input,input->off.ifhdrlen);
	T_IN4_ADDR addr;
	uint32_t len,align,hlen;

	int32_t icmpoff = input->off.ifhdrlen + GET_IP4_HDR_SIZE(iph);
	
	/* ICMP ヘッダの長さをチェックする。*/
	if (input->len < icmpoff + ICMP4_HDR_SIZE - input->off.ifalign) {
		goto buf_rel;
	}

	icmp4h = (T_ICMP4_HDR *)(input->buf + icmpoff);

	/* 4 オクテット境界のデータ長 */
	len   = input->len + input->off.ifalign- icmpoff;
	align = (len + 3) >> 2 << 2;

	/* 4 オクテット境界までパディングで埋める。*/
	if (align > len)
		memset((uint8_t*)input->buf + input->len, 0, (size_t)(align - len));

	/* チェックサムを計算する。*/
	if (cIPv4Functions_checkSum(icmp4h, align) != 0) {
		goto buf_rel;
	}

	/* メッセージの型により分岐する。*/
	switch (icmp4h->type) {
	  case ICMP4_ECHO_REQUEST:
		icmp_echo(p_cellcb,input,size);
		return IPPROTO_DONE;
		break;
	  case ICMP4_ECHO_REPLY:

#if 0

		icmp_echo_reply(idx,input, offset);

#endif	/* of #ifdef ICMP_CFG_CALLBACK_ECHO_REPLY */

		break;
	  case ICMP4_UNREACH:
		icmp_unreach(p_cellcb,input,size);
		break;
	  case ICMP4_REDIRECT:

#if 0

		addr = ntohl(icmp4h->data.addr);
		//syslog(LOG_INFO, "[ICMP] redirect, addr: %s.", ip2str(NULL, &addr));
		icmp_redirect(p_cellcb,input);

#else	/* of #if NUM_REDIRECT_ROUTE_ENTRY > 0 */

		addr = ntohl(icmp4h->data.addr);
		//syslog(LOG_INFO, "[ICMP] redirect ignored, addr: %s.", ip2str(NULL, &addr));

#endif	/* of #if NUM_REDIRECT_ROUTE_ENTRY > 0 */

		break;
	  default:
		syslog(LOG_INFO, "[ICMP] unknown type: %d.", icmp4h->type);
		break;
	}

buf_rel:
	eICMP4_input_inputp_dealloc((void*)inputp);
	return IPPROTO_DONE;
}


/* #[<ENTRY_PORT>]# eICMP4Error
 * entry port: eICMP4Error
 * signature:  sICMP4Error
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eICMP4Error_error
 * name:         eICMP4Error_error
 * global_name:  tICMP4_eICMP4Error_error
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eICMP4Error_error(CELLIDX idx, int8_t* inputp, int32_t size, uint8_t code)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	T_IP4_HDR	*ip4h,*sip4h;
	T_ICMP4_HDR	*icmp4h;
	T_NET_BUF	*output;
	T_NET_BUF   *input = (T_NET_BUF*)inputp;
	uint_t		len, ip4hl, align,slen;
	
	ip4h  = GET_IP4_HDR(input,input->off.ifhdrlen);
	ip4hl = GET_IP4_HDR_SIZE(ip4h);

	/* 送信用の IP データグラムを獲得する。*/
	if (input->len - ip4hl < 8)
		len = input->len - ip4hl;
	else
		len = 8;

	/* 4 オクテット境界のデータ長 */
	align = (len +ICMP4_HDR_SIZE +ip4hl+ 3) >> 2 << 2;

	slen = align+input->off.ifhdrlen+IP4_HDR_SIZE;

	if(cIPv4Reply_IPv4Reply_outputp_alloc((void**)&output,slen,TMO_ICMP_OUTPUT) != E_OK)
	  return;

	//オフセット情報hをコピーする
	output->off = input->off;
	output->off.iphdrlenall = IP4_HDR_SIZE;
	
	sip4h = output->buf + output->off.ifhdrlen;

	/* IP ヘッダを設定する ---------------------*/
	sip4h->vhl	= IP4_MAKE_VHL(IPV4_VERSION, IP4_HDR_SIZE >> 2);
	sip4h->len	= htons(slen);
	sip4h->proto	= IPPROTO_ICMP;
	sip4h->ttl	= IP4_DEFTTL;
	sip4h->type	= 0;
	sip4h->id	= ip4h->flg_off = ip4h->sum = 0;

	/* IP アドレスを設定する。*/
	sip4h->dst	= ip4h->src;
	sip4h->src = htonl(cIPv4Functions_getIPv4Address());
	/*IPheader ここまで---------------------*/

	/* ICMP ヘッダを設定する。*/
	icmp4h		= GET_ICMP4_HDR(output, output->off.ifhdrlen+IP4_HDR_SIZE);
	icmp4h->type	= ICMP4_UNREACH;
	icmp4h->code	= code;
	icmp4h->data.addr= 0;

	/* エラーが発生した IP ヘッダと データ 8 オクテットをコピーする。*/
	memcpy(GET_ICMP4_SDU(output, output->off.ifhdrlen+IP4_HDR_SIZE),
	       ip4h, (size_t)(ip4hl + len));

	/* 4 オクテット境界までパディングで埋める。*/
	if (align > len)
		memset((uint8_t*)GET_ICMP4_SDU(output, output->off.ifhdrlen+IP4_HDR_SIZE) + ip4hl + len,
		       0, (size_t)(align - len));

	/* チェックサムを計算する。*/
	icmp4h->sum = 0;
	icmp4h->sum = cIPv4Functions_checkSum(icmp4h, (uint_t)(ICMP4_HDR_SIZE + ip4hl + align));

	/* 送信する。*/
	cIPv4Reply_IPv4Reply((int8_t*)output,output->len+output->off.ifalign + sizeof(T_NET_BUF) - 4,TMO_ICMP_OUTPUT);

	//メモリを解放
	eICMP4Error_error_inputp_dealloc((void*)inputp);
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
