/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tArp_template.c => src/tArp.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * attr access macro #_CAAM_#
 * arpEntry         int32_t          ATTR_arpEntry   
 * arp_cache        T_ARP_ENTRY*     VAR_arp_cache   
 *
 * call port function #_TCPF_#
 * call port : cIPv4Functions  signature: sIPv4Functions context: task
 *   uint16_t       cIPv4Functions_checkSum( const int8_t* data, uint32_t len );
 *   T_IN4_ADDR     cIPv4Functions_getIPv4Address( );
 *   T_IN4_ADDR     cIPv4Functions_getIPv4Mask( );
 * call port : cEthernetRawOutput  signature: sEthernetRawOutput context: task
 *   ER             cEthernetRawOutput_ethernetRawOutput( int8_t* outputp, int32_t size, TMO tmout );
 * call port : cNetworkTimer  signature: sNetworkTimer context: task
 *   ER             cNetworkTimer_Timeout( RELTIM timout );
 * call port : cArpSemaphore  signature: sSemaphore context: task
 *   ER             cArpSemaphore_signal( );
 *   ER             cArpSemaphore_wait( );
 *   ER             cArpSemaphore_waitPolling( );
 *   ER             cArpSemaphore_waitTimeout( TMO timeout );
 *   ER             cArpSemaphore_initialize( );
 *   ER             cArpSemaphore_refer( T_RSEM* pk_semaphoreStatus );
 * allocator port for call port: cEthernetRawOutput func: ethernetRawOutput param: outputp
 *   ER             cEthernetRawOutput_ethernetRawOutput_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             cEthernetRawOutput_ethernetRawOutput_outputp_dealloc( const void* buf );
 *   ER             cEthernetRawOutput_ethernetRawOutput_outputp_reuse( void* buf );
 *   ER_UINT        cEthernetRawOutput_ethernetRawOutput_outputp_bufferSize( const void* buf );
 *   uint32_t       cEthernetRawOutput_ethernetRawOutput_outputp_bufferMaxSize( );
 * allocator port for call port: eArpInput func: arpInput param: inputp
 *   ER             eArpInput_arpInput_inputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eArpInput_arpInput_inputp_dealloc( const void* buf );
 *   ER             eArpInput_arpInput_inputp_reuse( void* buf );
 *   ER_UINT        eArpInput_arpInput_inputp_bufferSize( const void* buf );
 *   uint32_t       eArpInput_arpInput_inputp_bufferMaxSize( );
 * allocator port for call port: eArpOutput func: arpResolve param: outputp
 *   ER             eArpOutput_arpResolve_outputp_alloc( void** buf, const int32_t minlen, TMO tmout );
 *   ER             eArpOutput_arpResolve_outputp_dealloc( const void* buf );
 *   ER             eArpOutput_arpResolve_outputp_reuse( void* buf );
 *   ER_UINT        eArpOutput_arpResolve_outputp_bufferSize( const void* buf );
 *   uint32_t       eArpOutput_arpResolve_outputp_bufferMaxSize( );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tArp_tecsgen.h"

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif



const uint8_t ether_broad_cast_addr[6] = {
	UINT_C(0xff), UINT_C(0xff), UINT_C(0xff),
	UINT_C(0xff), UINT_C(0xff), UINT_C(0xff)
  };

/*
 *  arp_lookup -- ARP キャッシュの探索と登録
 *
 *    注意: SEM_ARP_CACHE_LOCK を獲得した状態で呼出すこと
 */

static T_ARP_ENTRY *
arp_lookup (CELLCB	*p_cellcb,T_IN4_ADDR addr, bool_t create)
{
	int32_t		ix, six;
	uint16_t	min;

	for (ix = ATTR_arpEntry; ix -- > 0; ) {
		if (VAR_arp_cache[ix].expire && VAR_arp_cache[ix].ip_addr == addr)
			return &VAR_arp_cache[ix];
	}

	/* create が真なら、新たなエントリを登録する。*/
	if (create) {

		/* まず、空きがあれば、その空きを利用する。*/
		for (ix = ATTR_arpEntry; ix -- > 0; ) {
			if (VAR_arp_cache[ix].expire == 0) {
				VAR_arp_cache[ix].ip_addr = addr;
				return &VAR_arp_cache[ix];
				}
			}

		/*
		 *  空きがなければ、タイムアウトまで時間が最短の
		 *  エントリーを破棄して利用する。
		 */
		syslog(LOG_EMERG, "[ARP] cache busy, size=%d", ATTR_arpEntry);
		min = 0xffff;
		for (six = ix = ATTR_arpEntry; ix -- > 0; )
			if (VAR_arp_cache[ix].expire < min) {
				six = ix;
				min = VAR_arp_cache[ix].expire;
				}
		VAR_arp_cache[six].expire  = 0;
		VAR_arp_cache[six].ip_addr = addr;
		return &VAR_arp_cache[six];
	}
	else
	  return NULL;
}
/*
 *  arp_request -- MAC アドレス解決要求
 */

static ER
arp_request (CELLCB	*p_cellcb,const uint8_t *macaddress, T_IN4_ADDR dst)
{

	/* Put statements here #_TEFB_# */
	ER		error;
	T_IN4_ADDR	src;
	T_ETHER_HDR	*eth;
	T_ARP_HDR	*arph;
	T_ETHER_ARP_HDR	*et_arph;
	T_NET_BUF	*arp_req;

	//NET_COUNT_ARP(net_count_arp.out_octets , IF_ARP_ETHER_HDR_SIZE - IF_HDR_SIZE);

	
	if ((error = cEthernetRawOutput_ethernetRawOutput_outputp_alloc((void **)&arp_req, IF_ARP_ETHER_HDR_SIZE, TMO_ARP_GET_NET_BUF)) == E_OK) {

		/* イーサネットヘッダを設定する。*/
		eth     = GET_ETHER_HDR(arp_req);
		memcpy(eth->dhost, ether_broad_cast_addr, 6);
		memcpy(eth->shost, macaddress,        6);
		eth->type = htons(ETHER_TYPE_ARP);

		/* ARP ヘッダを設定する。*/
		arph    = GET_ARP_HDR(arp_req);
		arph->hrd_addr  = htons(ARPHRD_ETHER);
		arph->proto     = htons(ETHER_TYPE_IP);
		arph->hdr_len   = sizeof(et_arph->shost);
		arph->proto_len = sizeof(et_arph->sproto);
		arph->opcode    = htons(ARPOP_REQUEST);

		/* イーサネット ARP ヘッダを設定する。*/
		et_arph = GET_ETHER_ARP_HDR(arp_req);
		src     = cIPv4Functions_getIPv4Address();
		memcpy(et_arph->shost, macaddress, 6);
		memset(et_arph->thost, 0, 6);
		ahtonl(et_arph->sproto, src);
		ahtonl(et_arph->tproto, dst);

		/* 送信する。*/
		error = cEthernetRawOutput_ethernetRawOutput((int8_t*)arp_req,GET_IF_ARP_HDR_SIZE(input), TMO_ARP_OUTPUT);
	}
	if (error != E_OK)
	  //NET_COUNT_ARP(net_count_arp.out_err_packets, 1);
	return error;
}




/*
 *  in_arpinput -- TCP/IP 用 ARP の入力関数
 */

static void
in_arpinput (CELLCB	*p_cellcb,const uint8_t *macaddress, T_NET_BUF *input)
{

	T_ETHER_ARP_HDR	*et_arph;
	T_IN4_ADDR	saddr, taddr;
	T_ARP_HDR *arph = GET_ARP_HDR(input);
	
	et_arph = GET_ETHER_ARP_HDR(input);

	ntoahl(saddr, et_arph->sproto);		/* 送信元 IP アドレス	*/
	ntoahl(taddr, et_arph->tproto);		/* 解決対象 IP アドレス	*/

	/*
	 *  以下の場合はエラー
	 *    ・送信ホストの物理アドレスが自分
	 *    ・送信ホストの物理アドレスがブロードキャスト
	 */

	if (memcmp(et_arph->shost, macaddress,6) == 0 ||
	    memcmp(et_arph->shost, ether_broad_cast_addr,6) == 0)
		goto err_ret;

	T_IN4_ADDR myaddr = cIPv4Functions_getIPv4Address();

	//ARP送信元のアドレスと自分のアドレスがかぶっていた場合
	//ARPとしては同じIPアドレスに２つのMACアドレスを登録することになるので
	//mikanARP重複のコールバック関数
	if(saddr == myaddr){
		syslog(LOG_EMERG,"ARP IP address duplicated %x\n",saddr);
		taddr = saddr;
		goto reply;
	}


	/*
	 *  以下の場合は何もしない。
	 *    ・解決対象 IP アドレスが自分ではない、注: 元の FreeBSD の
	 *      実装では、ARP PROXY 等のため、自分以外の IP アドレスの
	 *      解決も行っているが、本実装では、自分以外の IP
	 *      アドレスの解決は行わない。
	 */
	if (taddr != myaddr)
		goto buf_rel;


	/*
	 *  送信元 IP アドレスが ARP キャッシュにあるか調べる。
	 *  キャッシュになければ、新たにエントリを登録する。
	 */
	T_ARP_ENTRY *ent;
	cArpSemaphore_wait();
	ent = arp_lookup(p_cellcb,saddr, true);

	memcpy(ent->mac_addr, et_arph->shost, 6);
	ent->expire = ARP_CACHE_KEEP;

	/*
	 *  送信がペンデングされているフレームがあれば送信する。
	 */
	if (ent->hold) {

		/* フレームの Ethernet ヘッダを設定する。*/
		memcpy(GET_ETHER_HDR(ent->hold)->dhost, ent->mac_addr, 6);

		T_NET_BUF *pending;
		
		pending = ent->hold;
		ent->hold = NULL;
		cArpSemaphore_signal();

		/* ペンディングされているフレームを送信する。*/
		//IF_RAW_OUTPUT(pending, TMO_FEVR);mikan

		}else{
			cArpSemaphore_signal();
		}

  reply:

	/* アドレス解決要求でなければ終了 */
	if (ntohs(arph->opcode) != ARPOP_REQUEST)
		goto buf_rel;

	/* Ethernet ARP ヘッダを設定する。*/
	memcpy(et_arph->thost, et_arph->shost, 6);
	memcpy(et_arph->shost, macaddress, 6);
	memcpy(et_arph->tproto, (uint8_t*)&et_arph->sproto, sizeof(T_IN4_ADDR));
	ahtonl(et_arph->sproto, taddr);

	/* Ethernet ARP ヘッダを設定する。*/
	arph->opcode = htons(ARPOP_REPLY);

	/* Ethernet ヘッダを設定する。*/
	T_ETHER_HDR	*eth = GET_ETHER_HDR(input);
	memcpy(eth->dhost, eth->shost,6);
	memcpy(eth->shost, macaddress,6);

	/* ARP 応答を送信する。*/
	cEthernetRawOutput_ethernetRawOutput((int8_t*)input,GET_IF_ARP_HDR_SIZE(input),TMO_FEVR);
	return;
	
  err_ret:
	//MIBが入りますmikan
  buf_rel:
	eArpInput_arpInput_inputp_dealloc((void*)input);
}
/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eArpInput
 * entry port: eArpInput
 * signature:  sArpInput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eArpInput_arpInitialize
 * name:         eArpInput_arpInitialize
 * global_name:  tArp_eArpInput_arpInitialize
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eArpInput_arpInitialize(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	cNetworkTimer_Timeout(600);
}

/* #[<ENTRY_FUNC>]# eArpInput_arpInput
 * name:         eArpInput_arpInput
 * global_name:  tArp_eArpInput_arpInput
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eArpInput_arpInput(CELLIDX idx, int8_t* inputp, int32_t size, const uint8_t* macaddress)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */

	T_ARP_HDR *arph;
	T_NET_BUF *input = (T_NET_BUF*)inputp;
	
	/* ARP ヘッダの長さをチェックする。*/
	if (input->len < ETHER_ARP_HDR_SIZE)
		goto buf_rel;

	arph = GET_ARP_HDR(input);

	/*
	 *  物理アドレスフォーマットが Ehternet 以外
	 *  または、プロトコルが IP 以外はエラー。
	 */
	if (ntohs(arph->hrd_addr) != ARPHRD_ETHER ||
	    ntohs(arph->proto)    != ETHER_TYPE_IP)
		goto buf_rel;
	
	/* ARP ヘッダ + Ether ARP ヘッダの長さをチェックする。*/
	if (input->len < IF_ARP_ETHER_HDR_SIZE)
		goto buf_rel;
	
	in_arpinput(p_cellcb,macaddress, input);
	return;	

buf_rel:
	eArpInput_arpInput_inputp_dealloc((void *)inputp);
	
}

/* #[<ENTRY_PORT>]# eArpOutput
 * entry port: eArpOutput
 * signature:  sArpOutput
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eArpOutput_arpResolve
 * name:         eArpOutput_arpResolve
 * global_name:  tArp_eArpOutput_arpResolve
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eArpOutput_arpResolve(CELLIDX idx, int8_t* outputp, int32_t size,T_IN4_ADDR dstaddr,const uint8_t *macaddress,TMO tmout)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	T_ARP_ENTRY	*ent;
	T_ETHER_HDR	*eth;
	T_NET_BUF *output = (T_NET_BUF *)outputp;
	T_IN4_ADDR src,mask;
	src = cIPv4Functions_getIPv4Address();
	mask = cIPv4Functions_getIPv4Mask();

	eth = GET_ETHER_HDR(output);

	/*
	 *  次の場合は、イーサネットのブロードキャストアドレスを返す。
	 *
	 *    ・全ビットが 1
	 *    ・ホスト部の全ビットが 1 で、ネットワーク部がローカルアドレス
	 */
	if (dstaddr == IPV4_ADDR_BROADCAST ||
	    dstaddr == ((src & mask) | ~mask)) {
		memcpy(eth->dhost, ether_broad_cast_addr, 6);
		return cEthernetRawOutput_ethernetRawOutput(output,size,tmout);
		}

	/* 送信先 GW の IP アドレスが ARP キャッシュにあるか調べる。*/
	cArpSemaphore_wait();
	ent = arp_lookup(p_cellcb,dstaddr, true);
	if (ent->expire) {
		memcpy(eth->dhost, ent->mac_addr, 6);
		cArpSemaphore_signal();
		return cEthernetRawOutput_ethernetRawOutput(output,size,tmout);
	}
	else {
	 	/* 送信がペンデングされているフレームがあれば捨てる。*/
		if (ent->hold) {
			eArpOutput_arpResolve_outputp_dealloc((void*)ent->hold);
		}

		/*
		 *  送信をペンディングする。
		 *  IF でネットワークバッファを開放しないフラグが設定されているときは、
		 *  送信をペンディングしない。
		 */
		ent->hold = output;

		cArpSemaphore_signal();

		/* アドレス解決要求を送信する。*/
		return arp_request(p_cellcb,macaddress, dstaddr);
	}
}

/* #[<ENTRY_PORT>]# eArpTimer
 * entry port: eArpTimer
 * signature:  sCallTimerFunction
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eArpTimer_callFunction
 * name:         eArpTimer_callFunction
 * global_name:  tArp_eArpTimer_callFunction
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eArpTimer_callFunction(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	/* Put statements here #_TEFB_# */
	int32_t ix;
	cArpSemaphore_wait();

	for(ix = ATTR_arpEntry;ix-- > 0; ){
		if(VAR_arp_cache[ix].expire){
			VAR_arp_cache[ix].expire -= 600;
			if(VAR_arp_cache[ix].expire == 0){
				if(VAR_arp_cache[ix].hold){
					//MIBをやってmikan
					eArpInput_arpInput_inputp_dealloc((void*)VAR_arp_cache[ix].hold);
				}
				memset(&VAR_arp_cache[ix],0,sizeof(T_ARP_ENTRY));
			}
		}
	}

	cArpSemaphore_signal();
	cNetworkTimer_Timeout(600);//60s間隔で呼び出されるタイマ関数です
}

/* #[<POSTAMBLE>]#
 *   Put non-entry functions below.
 * #[</POSTAMBLE>]#*/
